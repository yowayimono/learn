<!--
 * @Author: yowayimono
 * @Date: 2023-05-12 21:26:47
 * @LastEditors: yowayimono
 * @LastEditTime: 2023-05-21 21:43:54
 * @Description: nothing
-->
布隆过滤器（Bloom Filter）是一种快速、高效的数据结构，主要用于判断一个元素是否存在于一个集合中。它通过使用多个哈希函数和一个位数组来实现。

具体而言，对于每个需要加入集合的元素，将其经过多个哈希函数映射到位数组上的多个位置，并将这些位置上的值设置为1。当需要查询某个元素是否在集合中时，同样经过多个哈希函数映射到位数组上的多个位置，并检查这些位置上的值是否都为1。若有任何一个位置上的值为0，则可以确定该元素一定不存在于集合中。如果所有位置上的值都为1，那么这个元素可能存在于集合中（有一定的误判率）。

下面是一个简单的 C++ 实现示例：

```cpp
#include <iostream>
#include <bitset>
#include <functional>

using namespace std;

class BloomFilter {
private:
    bitset<1000000> bits;
    hash<string> hash_func1;
    hash<string> hash_func2;
    hash<string> hash_func3;
public:
    BloomFilter() {}
    void add(string s) {
        bits[hash_func1(s) % bits.size()] = 1;
        bits[hash_func2(s) % bits.size()] = 1;
        bits[hash_func3(s) % bits.size()] = 1;
    }
    bool check(string s) {
        return bits[hash_func1(s) % bits.size()] &&
            bits[hash_func2(s) % bits.size()] &&
            bits[hash_func3(s) % bits.size()];
    }
};

int main() {
    BloomFilter bf;
    bf.add("hello");
    bf.add("world");
    cout << bf.check("hello") << endl;  // true
    cout << bf.check("world") << endl;  // true
    cout << bf.check("foo") << endl;  // false
    return 0;
}
```
这个实现使用了 3 个哈希函数和一个位数组大小为 1000000，可以根据需要调整位数组大小和哈希函数数量。虽然 Bloom Filter 可以高效地判断一个元素是否存在于一个集合中，但由于存在一定的误判率，所以适用于对误判率要求不高的场景。


### 布隆过滤器应用场景

布隆过滤器是一种用于快速判断一个元素是否属于一个集合的数据结构。它通过一个很小的位数组和一些哈希函数来实现。当一个元素被加入集合时，它会被分别经过多个哈希函数，得到多个哈希值，对应位数组中的这些位置都被置为 1。查询一个元素时，只需要将查询元素经过哈希函数得到多个哈希值，检查对应位数组中这些位置是否都为 1 即可。

布隆过滤器具有快速查询和占用空间小的优点，但它可能会产生一些误判，即判断某个元素在集合中，但实际上它并不在集合中。因此，布隆过滤器一般用于那些允许一定误判率的场景。

下面是一些布隆过滤器常见的应用场景：

1. 垃圾邮件过滤：对于一个发件人的邮箱地址，可以使用布隆过滤器来判断它是否是一个垃圾邮件发件人。

2. 网页爬取：在网页爬取的过程中，使用布隆过滤器来避免重复爬取已经爬取过的网页。

3. 缓存击穿：在分布式缓存中，使用布隆过滤器来快速判断一个请求的 key 是否存在于缓存中，从而避免缓存击穿的问题。

4. 数据库查询优化：在查询大量数据时，可以使用布隆过滤器来快速过滤掉一些不可能存在的数据，从而减少数据库的查询压力。

5. DNS 缓存：在 DNS 中，使用布隆过滤器来缓存一些 DNS 查询结果，从而避免重复查询 DNS 服务器。

在使用布隆过滤器时，需要根据实际情况选择合适的哈希函数个数和位数组大小，以及误判率的可接受范围。

### 多次哈希
在布隆过滤器中，哈希函数的作用是将数据映射到不同的位上，从而实现将数据存储到位数组中。如果哈希函数只执行一次，那么数据只会存储到一个位上，而布隆过滤器需要存储到多个位上才能够达到更好的误判率。因此，哈希函数需要执行多次，将数据映射到多个不同的位上。这样做的好处是可以增加误判率，同时也能够减小哈希冲突的概率。通常情况下，哈希函数执行的次数越多，误判率就越低。


### 总结
综上，布隆过滤器都是在特定的场景演化出来的东西，只有更适合的没有更好的，布隆过滤器往往需要很小的空间（一个比特数组），并且有一定容错率的场景，但就不是说布隆过滤器不需要解决哈希冲突，多次哈希就是为了解决哈希冲突，虽然不能完全解决，始终有一定的误判率。因为不需要存储键值对数据，所以不能用一般的方法解决哈希冲突。



今天就到这里，大家喜欢的点赞收藏，持续更新各种计算机知识。祝大家秋招斩获满意offer!

